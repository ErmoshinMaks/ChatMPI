#include <QtCore>
#include "mainwindow.h"
#include <QApplication>

#include "threadsqueue.hpp"
#include <QInputDialog>

#include <iostream>
#include <thread>
#include <sys/types.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <string.h>
#include <stdio.h>
#include <errno.h>
#include <unistd.h>
#include <stdlib.h>

const int PORT = 52002;
const char* SERVER_IP = "127.0.0.1";
char FIO_from[MESSAGE_SIZE] = "Максим Ермошин";
char FIO_to[MESSAGE_SIZE] = "Бортник Степан";


void receiveMessages(int sockfd, ThreadSafeQueue<ClientDTO>* queue) {
    char sendline[MESSAGE_SIZE];

    while(true) {
        memset(sendline, 0, sizeof(sendline));
        ClientDTO data;
        char buffer[sizeof(ClientDTO)];

        int n = read(sockfd, buffer, sizeof(ClientDTO));
        if(n < 0) {
            std::cerr << "Error reading from socket" << std::endl;
            break;
        }
        if(n == 0) {
            std::cout << "Server disconnected" << std::endl;
            break;
        }
        memcpy(&data, buffer, sizeof(data));
        queue->push(data);
        std::cout << "Received: " << data.message << std::endl;
    }
}

void sendMessages(int sockfd,sockaddr_in servaddr,sockaddr_in servaddr_to, ThreadSafeQueue<ClientDTO>* queue) {
    ClientDTO data;

    while(true) {
        // std::getline(std::cin, message);

        if (queue->empty())
            continue;
        if (queue->try_pop(data)){

            // memcpy(data.from, FIO_from,MESSAGE_SIZE);
            // memcpy(data.to,msg.name.c_str(),MESSAGE_SIZE);
            // memcpy(data.message, msg.mes.c_str(), sizeof(msg.mes));
            char buffer[sizeof(data)];
            memcpy(buffer, &data, sizeof(data));

            int n = write(sockfd, buffer, sizeof(buffer));
            if(n < 0) {
                std::cerr << "Error writing to socket" << std::endl;
                break;
            }
        }
    }
}

int drawMessages(int argc, char *argv[], ThreadSafeQueue<ClientDTO>* q_send, ThreadSafeQueue<ClientDTO>* q_rcv)
{
    QApplication a(argc, argv);
    bool ok = 0;
    ClientDTO msg;
    while(!ok){
        QString text = QInputDialog::getText(nullptr, "Авторизация", "Введите имя:", QLineEdit::Normal, QString(), &ok,Qt::WindowFlags() ,Qt::ImhNone);
        if (ok && !text.isEmpty()){
            qDebug() << "Введенный логин: " << text;
            memcpy(msg.from, text.toStdString().c_str(), sizeof(text.toStdString().c_str()));
            memcpy(msg.message, REGISTR_MES, sizeof(REGISTR_MES));
            q_send->push(msg);
        }
    }

    MainWindow w;
    w.get_queues(q_send, q_rcv);
    w.login(msg.from);
    w.show();
 
    return a.exec();
}


int main(int argc, char *argv[])
{
    ThreadSafeQueue<ClientDTO> queue_send;
    ThreadSafeQueue<ClientDTO> queue_rcv;

    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if(sockfd < 0) {
        std::cerr << "Error opening socket" << std::endl;
        return 1;
    }

    struct sockaddr_in servaddr;
    struct sockaddr_in servaddr_to;//test

    servaddr.sin_family = AF_INET;
    servaddr.sin_port = htons(PORT);
    inet_pton(AF_INET, SERVER_IP, &servaddr.sin_addr);

    if(connect(sockfd, (struct sockaddr*)&servaddr, sizeof(servaddr)) < 0) {
        std::cerr << "Error connecting to server" << std::endl;
        return 1;
    }

    // std::thread receiver(receiveMessages, sockfd, &queue_rcv);
    std::thread sender(sendMessages, sockfd,servaddr,servaddr_to, &queue_send);
    std::thread gui(drawMessages, argc, argv, &queue_send, &queue_rcv);

    // receiver.join();
    sender.join();
    gui.join();

    close(sockfd);
    return 0;
}